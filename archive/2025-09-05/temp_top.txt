// Simple WebSocket server managing tables up to 6 players each
import { WebSocketServer } from 'ws';
import { nanoid } from 'nanoid';

const PORT = process.env.PORT ? Number(process.env.PORT) : 8787;
const wss = new WebSocketServer({ port: PORT });

// tables: Map<tableId, { id, createdAt, seats: [ seat ], ownerId, started, state }>
// seat: { id, addr, ready, ws }
const tables = new Map();

function send(ws, type, data = {}) {
  try { ws.send(JSON.stringify({ type, ...data })); } catch {}
}

function broadcast(table, type, data = {}) {
  for (const seat of table.seats) {
    if (seat?.ws && seat.ws.readyState === 1) send(seat.ws, type, data);
  }
}

function getPublicTable(table) {
  return {
    id: table.id,
    createdAt: table.createdAt,
    started: !!table.started,
    ownerId: table.ownerId,
    seats: table.seats.map((s) => (s ? { id: s.id, addr: s.addr || null, ready: !!s.ready, balance: Number(s.balance || 0) } : null)),
  };
}

function ensureTable(tableId) {
  let table = tables.get(tableId);
  if (!table) {
    table = {
      id: tableId,
      createdAt: Date.now(),
      seats: new Array(6).fill(null),
      ownerId: null,
      started: false,
      state: {},
      bets: new Map(),
      shoe: [],
      shoeIdx: 0,
      burned: false,
    };
    tables.set(tableId, table);
  }
  return table;
}

const RANKS = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} return a; }
function newShoe(){ const d=[]; for(let r=0;r<13;r++){ for(let c=0;c<4;c++){ d.push(r);} } return shuffle(d); }
function draw(table){ if (!table.shoe || table.shoe.length - table.shoeIdx < 1){ table.shoe=newShoe(); table.shoeIdx=0; table.burned=false; } const v=table.shoe[table.shoeIdx++]; return v; }

function removeWs(ws) {
  for (const table of tables.values()) {
    let changed = false;
    for (let i = 0; i < table.seats.length; i++) {
